/*
Copyright (c) 2021, MapTiler.com & OpenMapTiles contributors.
All rights reserved.

Code license: BSD 3-Clause License

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Design license: CC-BY 4.0

See https://github.com/openmaptiles/openmaptiles/blob/master/LICENSE.md for details on usage
*/
// AUTOGENERATED BY Generate.java -- DO NOT MODIFY

package com.onthegomap.planetiler.basemap.generated;

import static com.onthegomap.planetiler.expression.Expression.*;

import com.onthegomap.planetiler.FeatureCollector;
import com.onthegomap.planetiler.expression.Expression;
import com.onthegomap.planetiler.expression.MultiExpression;
import com.onthegomap.planetiler.reader.SourceFeature;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * OSM element parsers generated from the <a href="https://github.com/omniscale/imposm3">imposm3</a> table definitions
 * in the <a href="https://github.com/openmaptiles/openmaptiles/blob/v3.13/openmaptiles.yaml">OpenMapTiles vector tile
 * schema</a>.
 * <p>
 * These filter and parse the raw OSM key/value attribute pairs on tags into records with fields that match the columns
 * in the tables that imposm3 would generate.  Layer implementations can "subscribe" to elements from each "table" but
 * implementing the table's {@code Handler} interface and use the element's typed API to access attributes.
 */
@SuppressWarnings("unused")
public class Tables {

  /** A parsed OSM element that would appear in a "row" of the imposm3 table. */
  public interface Row {

    /** Returns the original OSM element. */
    SourceFeature source();
  }

  /** A functional interface that the constructor of a new table row can be coerced to. */
  @FunctionalInterface
  public interface Constructor {

    Row create(SourceFeature source, String mappingKey);
  }

  /** The {@code rowClass} of an imposm3 table row and its constructor coerced to a {@link Constructor}. */
  public record RowClassAndConstructor(
    Class<? extends Row> rowClass,
    Constructor create
  ) {}

  /** A functional interface that the typed handler method that a layer implementation can be coerced to. */
  @FunctionalInterface
  public interface RowHandler<T extends Row> {

    /** Process a typed element according to the profile. */
    void process(T element, FeatureCollector features);
  }

  /** The {@code handlerClass} of a layer handler and it's {@code process} method coerced to a {@link RowHandler}. */
  public record RowHandlerAndClass<T extends Row>(
    Class<?> handlerClass,
    RowHandler<T> handler
  ) {}

  /** An OSM element that would appear in the {@code osm_water_polygon} table generated by imposm3. */
  public record OsmWaterPolygon(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String natural,
    @Override String landuse,
    @Override String waterway,
    @Override String water,
    @Override boolean isIntermittent,
    @Override boolean isTunnel,
    @Override boolean isBridge,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithNatural,
    WithLanduse,
    WithWaterway,
    WithWater,
    WithIsIntermittent,
    WithIsTunnel,
    WithIsBridge,
    WithSource {

    public OsmWaterPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("natural"),
        source.getString("landuse"),
        source.getString("waterway"),
        source.getString("water"),
        source.getBoolean("intermittent"),
        source.getBoolean("tunnel"),
        source.getBoolean("bridge"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "landuse",
          "reservoir",
          "basin",
          "salt_pond"
        ),
        matchAny(
          "leisure",
          "swimming_pool"
        ),
        matchAny(
          "natural",
          "water",
          "bay",
          "spring"
        ),
        matchAny(
          "waterway",
          "riverbank",
          "dock"
        ),
        matchAny(
          "water",
          "river"
        )
      ),
      not(
        matchAny(
          "covered",
          "yes"
        )
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmWaterPolygon}.
     */
    public interface Handler {

      void process(OsmWaterPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_waterway_linestring} table generated by imposm3. */
  public record OsmWaterwayLinestring(
    @Override String waterway,
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override boolean isTunnel,
    @Override boolean isBridge,
    @Override boolean isIntermittent,
    @Override SourceFeature source
  ) implements
    Row,
    WithWaterway,
    WithName,
    WithNameEn,
    WithNameDe,
    WithIsTunnel,
    WithIsBridge,
    WithIsIntermittent,
    WithSource {

    public OsmWaterwayLinestring(SourceFeature source, String mappingKey) {
      this(
        source.getString("waterway"),
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getBoolean("tunnel"),
        source.getBoolean("bridge"),
        source.getBoolean("intermittent"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "waterway",
        "stream",
        "river",
        "canal",
        "drain",
        "ditch"
      ),
      matchType("linestring")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmWaterwayLinestring}.
     */
    public interface Handler {

      void process(OsmWaterwayLinestring element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_landcover_polygon} table generated by imposm3. */
  public record OsmLandcoverPolygon(
    @Override String subclass,
    @Override String mappingKey,
    @Override SourceFeature source
  ) implements
    Row,
    WithSubclass,
    WithMappingKey,
    WithSource {

    public OsmLandcoverPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString(mappingKey), mappingKey, source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "landuse",
          "allotments",
          "farm",
          "farmland",
          "orchard",
          "plant_nursery",
          "vineyard",
          "grass",
          "grassland",
          "meadow",
          "forest",
          "village_green",
          "recreation_ground"
        ),
        matchAny(
          "natural",
          "wood",
          "wetland",
          "fell",
          "grassland",
          "heath",
          "scrub",
          "tundra",
          "glacier",
          "bare_rock",
          "scree",
          "beach",
          "sand",
          "dune"
        ),
        matchAny(
          "leisure",
          "park",
          "garden",
          "golf_course"
        ),
        matchAny(
          "wetland",
          "bog",
          "swamp",
          "wet_meadow",
          "marsh",
          "reedbed",
          "saltern",
          "tidalflat",
          "saltmarsh",
          "mangrove"
        )
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmLandcoverPolygon}.
     */
    public interface Handler {

      void process(OsmLandcoverPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_landuse_polygon} table generated by imposm3. */
  public record OsmLandusePolygon(
    @Override String landuse,
    @Override String amenity,
    @Override String leisure,
    @Override String tourism,
    @Override String place,
    @Override String waterway,
    @Override SourceFeature source
  ) implements
    Row,
    WithLanduse,
    WithAmenity,
    WithLeisure,
    WithTourism,
    WithPlace,
    WithWaterway,
    WithSource {

    public OsmLandusePolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("landuse"),
        source.getString("amenity"),
        source.getString("leisure"),
        source.getString("tourism"),
        source.getString("place"),
        source.getString("waterway"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "landuse",
          "railway",
          "cemetery",
          "military",
          "residential",
          "commercial",
          "industrial",
          "garages",
          "retail"
        ),
        matchAny(
          "amenity",
          "bus_station",
          "school",
          "university",
          "kindergarten",
          "college",
          "library",
          "hospital",
          "grave_yard"
        ),
        matchAny(
          "leisure",
          "stadium",
          "pitch",
          "playground",
          "track"
        ),
        matchAny(
          "tourism",
          "theme_park",
          "zoo"
        ),
        matchAny(
          "place",
          "suburb",
          "quarter",
          "neighbourhood"
        ),
        matchAny(
          "waterway",
          "dam"
        )
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmLandusePolygon}.
     */
    public interface Handler {

      void process(OsmLandusePolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_peak_point} table generated by imposm3. */
  public record OsmPeakPoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String ele,
    @Override String wikipedia,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithEle,
    WithWikipedia,
    WithSource {

    public OsmPeakPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("ele"),
        source.getString("wikipedia"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "natural",
        "peak",
        "volcano",
        "saddle"
      ),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmPeakPoint}.
     */
    public interface Handler {

      void process(OsmPeakPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_mountain_linestring} table generated by imposm3. */
  public record OsmMountainLinestring(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String wikipedia,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithWikipedia,
    WithSource {

    public OsmMountainLinestring(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("wikipedia"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "natural",
        "ridge",
        "cliff",
        "arete"
      ),
      matchType("linestring")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmMountainLinestring}.
     */
    public interface Handler {

      void process(OsmMountainLinestring element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_park_polygon} table generated by imposm3. */
  public record OsmParkPolygon(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String landuse,
    @Override String leisure,
    @Override String boundary,
    @Override String protectionTitle,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithLanduse,
    WithLeisure,
    WithBoundary,
    WithProtectionTitle,
    WithSource {

    public OsmParkPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("landuse"),
        source.getString("leisure"),
        source.getString("boundary"),
        source.getString("protection_title"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "leisure",
          "nature_reserve"
        ),
        matchAny(
          "boundary",
          "national_park",
          "protected_area"
        )
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmParkPolygon}.
     */
    public interface Handler {

      void process(OsmParkPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_aeroway_polygon} table generated by imposm3. */
  public record OsmAerowayPolygon(
    @Override String ref,
    @Override String aeroway,
    @Override SourceFeature source
  ) implements
    Row,
    WithRef,
    WithAeroway,
    WithSource {

    public OsmAerowayPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("ref"),
        source.getString(mappingKey),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "aeroway",
          "aerodrome",
          "heliport",
          "runway",
          "helipad",
          "taxiway",
          "apron"),
        matchAny(
          "area:aeroway",
          "aerodrome",
          "heliport",
          "runway",
          "helipad",
          "taxiway",
          "apron")
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmAerowayPolygon}.
     */
    public interface Handler {

      void process(OsmAerowayPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_aeroway_linestring} table generated by imposm3. */
  public record OsmAerowayLinestring(
    @Override String ref,
    @Override String aeroway,
    @Override SourceFeature source
  ) implements
    Row,
    WithRef,
    WithAeroway,
    WithSource {

    public OsmAerowayLinestring(SourceFeature source, String mappingKey) {
      this(
        source.getString("ref"),
        source.getString("aeroway"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "aeroway",
        "runway",
        "taxiway"
      ),
      matchType("linestring")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmAerowayLinestring}.
     */
    public interface Handler {

      void process(OsmAerowayLinestring element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_aeroway_point} table generated by imposm3. */
  public record OsmAerowayPoint(
    @Override String ref,
    @Override String aeroway,
    @Override SourceFeature source
  ) implements
    Row,
    WithRef,
    WithAeroway,
    WithSource {

    public OsmAerowayPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("ref"),
        source.getString("aeroway"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "aeroway",
        "gate"
      ),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmAerowayPoint}.
     */
    public interface Handler {

      void process(OsmAerowayPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_highway_linestring} table generated by imposm3. */
  public record OsmHighwayLinestring(
    @Override String highway,
    @Override String construction,
    @Override String ref,
    @Override String network,
    @Override int zOrder,
    @Override long layer,
    @Override long level,
    @Override boolean indoor,
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String shortName,
    @Override boolean isTunnel,
    @Override boolean isBridge,
    @Override boolean isRamp,
    @Override boolean isFord,
    @Override int isOneway,
    @Override boolean isArea,
    @Override String service,
    @Override String access,
    @Override boolean toll,
    @Override String usage,
    @Override String publicTransport,
    @Override String manMade,
    @Override String bicycle,
    @Override String foot,
    @Override String horse,
    @Override String mtbScale,
    @Override String sacScale,
    @Override String surface,
    @Override boolean expressway,
    @Override SourceFeature source
  ) implements
    Row,
    WithHighway,
    WithConstruction,
    WithRef,
    WithNetwork,
    WithZOrder,
    WithLayer,
    WithLevel,
    WithIndoor,
    WithName,
    WithNameEn,
    WithNameDe,
    WithShortName,
    WithIsTunnel,
    WithIsBridge,
    WithIsRamp,
    WithIsFord,
    WithIsOneway,
    WithIsArea,
    WithService,
    WithAccess,
    WithToll,
    WithUsage,
    WithPublicTransport,
    WithManMade,
    WithBicycle,
    WithFoot,
    WithHorse,
    WithMtbScale,
    WithSacScale,
    WithSurface,
    WithExpressway,
    WithSource {

    public OsmHighwayLinestring(SourceFeature source, String mappingKey) {
      this(
        source.getString("highway"),
        source.getString("construction"),
        source.getString("ref"),
        source.getString("network"),
        source.getWayZorder(),
        source.getLong("layer"),
        source.getLong("level"),
        source.getBoolean("indoor"),
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("short_name"),
        source.getBoolean("tunnel"),
        source.getBoolean("bridge"),
        source.getBoolean("ramp"),
        source.getBoolean("ford"),
        source.getDirection("oneway"),
        source.getBoolean("area"),
        source.getString("service"),
        source.getString("access"),
        source.getBoolean("toll"),
        source.getString("usage"),
        source.getString("public_transport"),
        source.getString("man_made"),
        source.getString("bicycle"),
        source.getString("foot"),
        source.getString("horse"),
        source.getString("mtb:scale"),
        source.getString("sac_scale"),
        source.getString("surface"),
        source.getBoolean("expressway"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "highway",
          "motorway",
          "motorway_link",
          "trunk",
          "trunk_link",
          "primary",
          "primary_link",
          "secondary",
          "secondary_link",
          "tertiary",
          "tertiary_link",
          "unclassified",
          "residential",
          "living_street",
          "road",
          "pedestrian",
          "path",
          "footway",
          "cycleway",
          "steps",
          "bridleway",
          "corridor",
          "service",
          "track",
          "raceway",
          "busway",
          "construction"
        ),
        matchAny(
          "public_transport",
          "platform"
        ),
        matchAny(
          "man_made",
          "pier"
        ),
        matchAny(
          "service",
          "driveway",
          "parking_aisle")
      ),
      matchType("linestring")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmHighwayLinestring}.
     */
    public interface Handler {

      void process(OsmHighwayLinestring element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_railway_linestring} table generated by imposm3. */
  public record OsmRailwayLinestring(
    @Override String railway,
    @Override String ref,
    @Override String network,
    @Override int zOrder,
    @Override long layer,
    @Override long level,
    @Override boolean indoor,
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String shortName,
    @Override boolean isTunnel,
    @Override boolean isBridge,
    @Override boolean isRamp,
    @Override boolean isFord,
    @Override int isOneway,
    @Override boolean isArea,
    @Override String service,
    @Override String usage,
    @Override SourceFeature source
  ) implements
    Row,
    WithRailway,
    WithRef,
    WithNetwork,
    WithZOrder,
    WithLayer,
    WithLevel,
    WithIndoor,
    WithName,
    WithNameEn,
    WithNameDe,
    WithShortName,
    WithIsTunnel,
    WithIsBridge,
    WithIsRamp,
    WithIsFord,
    WithIsOneway,
    WithIsArea,
    WithService,
    WithUsage,
    WithSource {

    public OsmRailwayLinestring(SourceFeature source, String mappingKey) {
      this(
        source.getString("railway"),
        source.getString("ref"),
        source.getString("network"),
        source.getWayZorder(),
        source.getLong("layer"),
        source.getLong("level"),
        source.getBoolean("indoor"),
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("short_name"),
        source.getBoolean("tunnel"),
        source.getBoolean("bridge"),
        source.getBoolean("ramp"),
        source.getBoolean("ford"),
        source.getDirection("oneway"),
        source.getBoolean("area"),
        source.getString("service"),
        source.getString("usage"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "railway",
        "rail",
        "narrow_gauge",
        "preserved",
        "funicular",
        "subway",
        "light_rail",
        "monorail",
        "tram"
      ),
      matchType("linestring")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmRailwayLinestring}.
     */
    public interface Handler {

      void process(OsmRailwayLinestring element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_aerialway_linestring} table generated by imposm3. */
  public record OsmAerialwayLinestring(
    @Override String aerialway,
    @Override int zOrder,
    @Override long layer,
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String shortName,
    @Override boolean isTunnel,
    @Override boolean isBridge,
    @Override boolean isRamp,
    @Override boolean isFord,
    @Override int isOneway,
    @Override boolean isArea,
    @Override String service,
    @Override String usage,
    @Override SourceFeature source
  ) implements
    Row,
    WithAerialway,
    WithZOrder,
    WithLayer,
    WithName,
    WithNameEn,
    WithNameDe,
    WithShortName,
    WithIsTunnel,
    WithIsBridge,
    WithIsRamp,
    WithIsFord,
    WithIsOneway,
    WithIsArea,
    WithService,
    WithUsage,
    WithSource {

    public OsmAerialwayLinestring(SourceFeature source, String mappingKey) {
      this(
        source.getString("aerialway"),
        source.getWayZorder(),
        source.getLong("layer"),
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("short_name"),
        source.getBoolean("tunnel"),
        source.getBoolean("bridge"),
        source.getBoolean("ramp"),
        source.getBoolean("ford"),
        source.getDirection("oneway"),
        source.getBoolean("area"),
        source.getString("service"),
        source.getString("usage"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "aerialway",
        "cable_car",
        "gondola"
      ),
      matchType("linestring")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmAerialwayLinestring}.
     */
    public interface Handler {

      void process(OsmAerialwayLinestring element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_shipway_linestring} table generated by imposm3. */
  public record OsmShipwayLinestring(
    @Override String shipway,
    @Override int zOrder,
    @Override long layer,
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String shortName,
    @Override boolean isTunnel,
    @Override boolean isBridge,
    @Override boolean isRamp,
    @Override boolean isFord,
    @Override int isOneway,
    @Override boolean isArea,
    @Override String service,
    @Override String usage,
    @Override SourceFeature source
  ) implements
    Row,
    WithShipway,
    WithZOrder,
    WithLayer,
    WithName,
    WithNameEn,
    WithNameDe,
    WithShortName,
    WithIsTunnel,
    WithIsBridge,
    WithIsRamp,
    WithIsFord,
    WithIsOneway,
    WithIsArea,
    WithService,
    WithUsage,
    WithSource {

    public OsmShipwayLinestring(SourceFeature source, String mappingKey) {
      this(
        source.getString("route"),
        source.getWayZorder(),
        source.getLong("layer"),
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("short_name"),
        source.getBoolean("tunnel"),
        source.getBoolean("bridge"),
        source.getBoolean("ramp"),
        source.getBoolean("ford"),
        source.getDirection("oneway"),
        source.getBoolean("area"),
        source.getString("service"),
        source.getString("usage"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "route",
        "ferry"
      ),
      matchType("linestring")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmShipwayLinestring}.
     */
    public interface Handler {

      void process(OsmShipwayLinestring element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_highway_polygon} table generated by imposm3. */
  public record OsmHighwayPolygon(
    @Override String highway,
    @Override int zOrder,
    @Override long layer,
    @Override long level,
    @Override boolean indoor,
    @Override boolean isArea,
    @Override String publicTransport,
    @Override String manMade,
    @Override String service,
    @Override SourceFeature source
  ) implements
    Row,
    WithHighway,
    WithZOrder,
    WithLayer,
    WithLevel,
    WithIndoor,
    WithIsArea,
    WithPublicTransport,
    WithManMade,
    WithService,
    WithSource {

    public OsmHighwayPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("highway"),
        source.getWayZorder(),
        source.getLong("layer"),
        source.getLong("level"),
        source.getBoolean("indoor"),
        source.getBoolean("area"),
        source.getString("public_transport"),
        source.getString("man_made"),
        source.getString("service"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "highway",
          "path",
          "cycleway",
          "bridleway",
          "footway",
          "corridor",
          "pedestrian",
          "steps"
        ),
        matchAny(
          "public_transport",
          "platform"
        ),
        matchAny(
          "man_made",
          "bridge",
          "pier"
        )
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmHighwayPolygon}.
     */
    public interface Handler {

      void process(OsmHighwayPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_highway_point} table generated by imposm3. */
  public record OsmHighwayPoint(
    @Override String highway,
    @Override int zOrder,
    @Override long layer,
    @Override long level,
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String ref,
    @Override SourceFeature source
  ) implements
    Row,
    WithHighway,
    WithZOrder,
    WithLayer,
    WithLevel,
    WithName,
    WithNameEn,
    WithNameDe,
    WithRef,
    WithSource {

    public OsmHighwayPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("highway"),
        source.getWayZorder(),
        source.getLong("layer"),
        source.getLong("level"),
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("ref"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "highway",
        "motorway_junction"
      ),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmHighwayPoint}.
     */
    public interface Handler {

      void process(OsmHighwayPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_building_polygon} table generated by imposm3. */
  public record OsmBuildingPolygon(
    @Override String material,
    @Override String colour,
    @Override String building,
    @Override String buildingpart,
    @Override String buildingheight,
    @Override String buildingminHeight,
    @Override String buildinglevels,
    @Override String buildingminLevel,
    @Override String height,
    @Override String minHeight,
    @Override String levels,
    @Override String minLevel,
    @Override SourceFeature source
  ) implements
    Row,
    WithMaterial,
    WithColour,
    WithBuilding,
    WithBuildingpart,
    WithBuildingheight,
    WithBuildingminHeight,
    WithBuildinglevels,
    WithBuildingminLevel,
    WithHeight,
    WithMinHeight,
    WithLevels,
    WithMinLevel,
    WithSource {

    public OsmBuildingPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("building:material"),
        source.getString("building:colour"),
        source.getString("building"),
        source.getString("building:part"),
        source.getString("building:height"),
        source.getString("building:min_height"),
        source.getString("building:levels"),
        source.getString("building:min_level"),
        source.getString("height"),
        source.getString("min_height"),
        source.getString("levels"),
        source.getString("min_level"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchField("building:part"),
        matchField("building"),
        matchAny(
          "aeroway",
          "terminal",
          "hangar"
        ),
        matchAny(
          "location",
          "underground"
        )
      ),
      not(
        matchAny(
          "building",
          "no",
          "none",
          "No"
        )
      ),
      not(
        matchAny(
          "building:part",
          "no",
          "none",
          "No"
        )
      ),
      not(
        matchAny(
          "man_made",
          "bridge"
        )
      ),
      not(
        matchAny(
          "location",
          "underground"
        )
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmBuildingPolygon}.
     */
    public interface Handler {

      void process(OsmBuildingPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_marine_point} table generated by imposm3. */
  public record OsmMarinePoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String place,
    @Override long rank,
    @Override boolean isIntermittent,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithPlace,
    WithRank,
    WithIsIntermittent,
    WithSource {

    public OsmMarinePoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("place"),
        source.getLong("rank"),
        source.getBoolean("intermittent"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "place",
        "ocean",
        "sea"),
      matchField("name"),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmMarinePoint}.
     */
    public interface Handler {

      void process(OsmMarinePoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_continent_point} table generated by imposm3. */
  public record OsmContinentPoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithSource {

    public OsmContinentPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "place",
        "continent"
      ),
      matchField("name"),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmContinentPoint}.
     */
    public interface Handler {

      void process(OsmContinentPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_country_point} table generated by imposm3. */
  public record OsmCountryPoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override long rank,
    @Override String countryCodeIso31661Alpha2,
    @Override String iso31661Alpha2,
    @Override String iso31661,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithRank,
    WithCountryCodeIso31661Alpha2,
    WithIso31661Alpha2,
    WithIso31661,
    WithSource {

    public OsmCountryPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getLong("rank"),
        source.getString("country_code_iso3166_1_alpha_2"),
        source.getString("ISO3166-1:alpha2"),
        source.getString("ISO3166-1"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "place",
        "country"
      ),
      matchField("name"),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmCountryPoint}.
     */
    public interface Handler {

      void process(OsmCountryPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_island_polygon} table generated by imposm3. */
  public record OsmIslandPolygon(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override long rank,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithRank,
    WithSource {

    public OsmIslandPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getLong("rank"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "place",
        "island"
      ),
      matchField("name"),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmIslandPolygon}.
     */
    public interface Handler {

      void process(OsmIslandPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_island_point} table generated by imposm3. */
  public record OsmIslandPoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override long rank,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithRank,
    WithSource {

    public OsmIslandPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getLong("rank"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "place",
        "island"
      ),
      matchField("name"),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmIslandPoint}.
     */
    public interface Handler {

      void process(OsmIslandPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_state_point} table generated by imposm3. */
  public record OsmStatePoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String place,
    @Override String isInCountry,
    @Override String isInCountryCode,
    @Override String ref,
    @Override long rank,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithPlace,
    WithIsInCountry,
    WithIsInCountryCode,
    WithRef,
    WithRank,
    WithSource {

    public OsmStatePoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("place"),
        source.getString("is_in:country"),
        source.getString("is_in:country_code"),
        source.getString("ref"),
        source.getLong("rank"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "place",
        "state",
        "province"
      ),
      matchField("name"),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmStatePoint}.
     */
    public interface Handler {

      void process(OsmStatePoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_city_point} table generated by imposm3. */
  public record OsmCityPoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String place,
    @Override long population,
    @Override String capital,
    @Override long rank,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithPlace,
    WithPopulation,
    WithCapital,
    WithRank,
    WithSource {

    public OsmCityPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("place"),
        source.getLong("population"),
        source.getString("capital"),
        source.getLong("rank"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      matchAny(
        "place",
        "city",
        "town",
        "village",
        "hamlet",
        "suburb",
        "quarter",
        "neighbourhood",
        "isolated_dwelling"
      ),
      matchField("name"),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmCityPoint}.
     */
    public interface Handler {

      void process(OsmCityPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_housenumber_point} table generated by imposm3. */
  public record OsmHousenumberPoint(
    @Override String housenumber,
    @Override SourceFeature source
  ) implements
    Row,
    WithHousenumber,
    WithSource {

    public OsmHousenumberPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("addr:housenumber"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = or(
      and(
        matchField("addr:housenumber"),
        matchType("point")
      ),
      and(
        matchField("addr:housenumber"),
        matchType("polygon")
      )
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmHousenumberPoint}.
     */
    public interface Handler {

      void process(OsmHousenumberPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_poi_point} table generated by imposm3. */
  public record OsmPoiPoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String subclass,
    @Override String mappingKey,
    @Override String station,
    @Override String funicular,
    @Override String information,
    @Override String uicRef,
    @Override String religion,
    @Override long level,
    @Override boolean indoor,
    @Override long layer,
    @Override String sport,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithSubclass,
    WithMappingKey,
    WithStation,
    WithFunicular,
    WithInformation,
    WithUicRef,
    WithReligion,
    WithLevel,
    WithIndoor,
    WithLayer,
    WithSport,
    WithSource {

    public OsmPoiPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString(mappingKey),
        mappingKey,
        source.getString("station"),
        source.getString("funicular"),
        source.getString("information"),
        source.getString("uic_ref"),
        source.getString("religion"),
        source.getLong("level"),
        source.getBoolean("indoor"),
        source.getLong("layer"),
        source.getString("sport"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "aerialway",
          "station"
        ),
        matchAny(
          "amenity",
          "arts_centre",
          "bank",
          "bar",
          "bbq",
          "bicycle_parking",
          "bicycle_rental",
          "biergarten",
          "bus_station",
          "cafe",
          "cinema",
          "clinic",
          "college",
          "community_centre",
          "courthouse",
          "dentist",
          "doctors",
          "drinking_water",
          "fast_food",
          "ferry_terminal",
          "fire_station",
          "food_court",
          "fuel",
          "grave_yard",
          "hospital",
          "ice_cream",
          "kindergarten",
          "library",
          "marketplace",
          "motorcycle_parking",
          "nightclub",
          "nursing_home",
          "parking",
          "pharmacy",
          "place_of_worship",
          "police",
          "post_box",
          "post_office",
          "prison",
          "pub",
          "public_building",
          "recycling",
          "restaurant",
          "school",
          "shelter",
          "swimming_pool",
          "taxi",
          "telephone",
          "theatre",
          "toilets",
          "townhall",
          "university",
          "veterinary",
          "waste_basket"
        ),
        matchAny(
          "barrier",
          "bollard",
          "border_control",
          "cycle_barrier",
          "gate",
          "lift_gate",
          "sally_port",
          "stile",
          "toll_booth"
        ),
        matchAny(
          "building",
          "dormitory"
        ),
        matchAny(
          "highway",
          "bus_stop"
        ),
        matchAny(
          "historic",
          "monument",
          "castle",
          "ruins"
        ),
        matchAny(
          "landuse",
          "basin",
          "brownfield",
          "cemetery",
          "reservoir",
          "winter_sports"
        ),
        matchAny(
          "leisure",
          "dog_park",
          "escape_game",
          "garden",
          "golf_course",
          "ice_rink",
          "hackerspace",
          "marina",
          "miniature_golf",
          "park",
          "pitch",
          "playground",
          "sports_centre",
          "stadium",
          "swimming_area",
          "swimming_pool",
          "water_park"
        ),
        matchAny(
          "office",
          "diplomatic"
        ),
        matchAny(
          "railway",
          "halt",
          "station",
          "subway_entrance",
          "train_station_entrance",
          "tram_stop"
        ),
        matchAny(
          "shop",
          "accessories",
          "alcohol",
          "antiques",
          "art",
          "bag",
          "bakery",
          "beauty",
          "bed",
          "beverages",
          "bicycle",
          "books",
          "boutique",
          "butcher",
          "camera",
          "car",
          "car_repair",
          "car_parts",
          "carpet",
          "charity",
          "chemist",
          "chocolate",
          "clothes",
          "coffee",
          "computer",
          "confectionery",
          "convenience",
          "copyshop",
          "cosmetics",
          "deli",
          "delicatessen",
          "department_store",
          "doityourself",
          "dry_cleaning",
          "electronics",
          "erotic",
          "fabric",
          "florist",
          "frozen_food",
          "furniture",
          "garden_centre",
          "general",
          "gift",
          "greengrocer",
          "hairdresser",
          "hardware",
          "hearing_aids",
          "hifi",
          "ice_cream",
          "interior_decoration",
          "jewelry",
          "kiosk",
          "lamps",
          "laundry",
          "locksmith",
          "mall",
          "massage",
          "mobile_phone",
          "motorcycle",
          "music",
          "musical_instrument",
          "newsagent",
          "optician",
          "outdoor",
          "perfume",
          "perfumery",
          "pet",
          "photo",
          "second_hand",
          "shoes",
          "sports",
          "stationery",
          "supermarket",
          "tailor",
          "tattoo",
          "ticket",
          "tobacco",
          "toys",
          "travel_agency",
          "video",
          "video_games",
          "watches",
          "weapons",
          "wholesale",
          "wine"
        ),
        matchAny(
          "sport",
          "american_football",
          "archery",
          "athletics",
          "australian_football",
          "badminton",
          "baseball",
          "basketball",
          "beachvolleyball",
          "billiards",
          "bmx",
          "boules",
          "bowls",
          "boxing",
          "canadian_football",
          "canoe",
          "chess",
          "climbing",
          "climbing_adventure",
          "cricket",
          "cricket_nets",
          "croquet",
          "curling",
          "cycling",
          "disc_golf",
          "diving",
          "dog_racing",
          "equestrian",
          "fatsal",
          "field_hockey",
          "free_flying",
          "gaelic_games",
          "golf",
          "gymnastics",
          "handball",
          "hockey",
          "horse_racing",
          "horseshoes",
          "ice_hockey",
          "ice_stock",
          "judo",
          "karting",
          "korfball",
          "long_jump",
          "model_aerodrome",
          "motocross",
          "motor",
          "multi",
          "netball",
          "orienteering",
          "paddle_tennis",
          "paintball",
          "paragliding",
          "pelota",
          "racquet",
          "rc_car",
          "rowing",
          "rugby",
          "rugby_league",
          "rugby_union",
          "running",
          "sailing",
          "scuba_diving",
          "shooting",
          "shooting_range",
          "skateboard",
          "skating",
          "skiing",
          "soccer",
          "surfing",
          "swimming",
          "table_soccer",
          "table_tennis",
          "team_handball",
          "tennis",
          "toboggan",
          "volleyball",
          "water_ski",
          "yoga"
        ),
        matchAny(
          "tourism",
          "alpine_hut",
          "aquarium",
          "artwork",
          "attraction",
          "bed_and_breakfast",
          "camp_site",
          "caravan_site",
          "chalet",
          "gallery",
          "guest_house",
          "hostel",
          "hotel",
          "information",
          "motel",
          "museum",
          "picnic_site",
          "theme_park",
          "viewpoint",
          "zoo"
        ),
        matchAny(
          "waterway",
          "dock"
        )
      ),
      matchType("point")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmPoiPoint}.
     */
    public interface Handler {

      void process(OsmPoiPoint element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_poi_polygon} table generated by imposm3. */
  public record OsmPoiPolygon(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String subclass,
    @Override String mappingKey,
    @Override String station,
    @Override String funicular,
    @Override String information,
    @Override String uicRef,
    @Override String religion,
    @Override long level,
    @Override boolean indoor,
    @Override long layer,
    @Override String sport,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithSubclass,
    WithMappingKey,
    WithStation,
    WithFunicular,
    WithInformation,
    WithUicRef,
    WithReligion,
    WithLevel,
    WithIndoor,
    WithLayer,
    WithSport,
    WithSource {

    public OsmPoiPolygon(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString(mappingKey),
        mappingKey,
        source.getString("station"),
        source.getString("funicular"),
        source.getString("information"),
        source.getString("uic_ref"),
        source.getString("religion"),
        source.getLong("level"),
        source.getBoolean("indoor"),
        source.getLong("layer"),
        source.getString("sport"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = and(
      or(
        matchAny(
          "aerialway",
          "station"
        ),
        matchAny(
          "amenity",
          "arts_centre",
          "bank",
          "bar",
          "bbq",
          "bicycle_parking",
          "bicycle_rental",
          "biergarten",
          "bus_station",
          "cafe",
          "cinema",
          "clinic",
          "college",
          "community_centre",
          "courthouse",
          "dentist",
          "doctors",
          "drinking_water",
          "fast_food",
          "ferry_terminal",
          "fire_station",
          "food_court",
          "fuel",
          "grave_yard",
          "hospital",
          "ice_cream",
          "kindergarten",
          "library",
          "marketplace",
          "motorcycle_parking",
          "nightclub",
          "nursing_home",
          "parking",
          "pharmacy",
          "place_of_worship",
          "police",
          "post_box",
          "post_office",
          "prison",
          "pub",
          "public_building",
          "recycling",
          "restaurant",
          "school",
          "shelter",
          "swimming_pool",
          "taxi",
          "telephone",
          "theatre",
          "toilets",
          "townhall",
          "university",
          "veterinary",
          "waste_basket"
        ),
        matchAny(
          "barrier",
          "bollard",
          "border_control",
          "cycle_barrier",
          "gate",
          "lift_gate",
          "sally_port",
          "stile",
          "toll_booth"
        ),
        matchAny(
          "building",
          "dormitory"
        ),
        matchAny(
          "highway",
          "bus_stop"
        ),
        matchAny(
          "historic",
          "monument",
          "castle",
          "ruins"
        ),
        matchAny(
          "landuse",
          "basin",
          "brownfield",
          "cemetery",
          "reservoir",
          "winter_sports"
        ),
        matchAny(
          "leisure",
          "dog_park",
          "escape_game",
          "garden",
          "golf_course",
          "ice_rink",
          "hackerspace",
          "marina",
          "miniature_golf",
          "park",
          "pitch",
          "playground",
          "sports_centre",
          "stadium",
          "swimming_area",
          "swimming_pool",
          "water_park"
        ),
        matchAny(
          "office",
          "diplomatic"
        ),
        matchAny(
          "railway",
          "halt",
          "station",
          "subway_entrance",
          "train_station_entrance",
          "tram_stop"
        ),
        matchAny(
          "shop",
          "accessories",
          "alcohol",
          "antiques",
          "art",
          "bag",
          "bakery",
          "beauty",
          "bed",
          "beverages",
          "bicycle",
          "books",
          "boutique",
          "butcher",
          "camera",
          "car",
          "car_repair",
          "car_parts",
          "carpet",
          "charity",
          "chemist",
          "chocolate",
          "clothes",
          "coffee",
          "computer",
          "confectionery",
          "convenience",
          "copyshop",
          "cosmetics",
          "deli",
          "delicatessen",
          "department_store",
          "doityourself",
          "dry_cleaning",
          "electronics",
          "erotic",
          "fabric",
          "florist",
          "frozen_food",
          "furniture",
          "garden_centre",
          "general",
          "gift",
          "greengrocer",
          "hairdresser",
          "hardware",
          "hearing_aids",
          "hifi",
          "ice_cream",
          "interior_decoration",
          "jewelry",
          "kiosk",
          "lamps",
          "laundry",
          "locksmith",
          "mall",
          "massage",
          "mobile_phone",
          "motorcycle",
          "music",
          "musical_instrument",
          "newsagent",
          "optician",
          "outdoor",
          "perfume",
          "perfumery",
          "pet",
          "photo",
          "second_hand",
          "shoes",
          "sports",
          "stationery",
          "supermarket",
          "tailor",
          "tattoo",
          "ticket",
          "tobacco",
          "toys",
          "travel_agency",
          "video",
          "video_games",
          "watches",
          "weapons",
          "wholesale",
          "wine"
        ),
        matchAny(
          "sport",
          "american_football",
          "archery",
          "athletics",
          "australian_football",
          "badminton",
          "baseball",
          "basketball",
          "beachvolleyball",
          "billiards",
          "bmx",
          "boules",
          "bowls",
          "boxing",
          "canadian_football",
          "canoe",
          "chess",
          "climbing",
          "climbing_adventure",
          "cricket",
          "cricket_nets",
          "croquet",
          "curling",
          "cycling",
          "disc_golf",
          "diving",
          "dog_racing",
          "equestrian",
          "fatsal",
          "field_hockey",
          "free_flying",
          "gaelic_games",
          "golf",
          "gymnastics",
          "handball",
          "hockey",
          "horse_racing",
          "horseshoes",
          "ice_hockey",
          "ice_stock",
          "judo",
          "karting",
          "korfball",
          "long_jump",
          "model_aerodrome",
          "motocross",
          "motor",
          "multi",
          "netball",
          "orienteering",
          "paddle_tennis",
          "paintball",
          "paragliding",
          "pelota",
          "racquet",
          "rc_car",
          "rowing",
          "rugby",
          "rugby_league",
          "rugby_union",
          "running",
          "sailing",
          "scuba_diving",
          "shooting",
          "shooting_range",
          "skateboard",
          "skating",
          "skiing",
          "soccer",
          "surfing",
          "swimming",
          "table_soccer",
          "table_tennis",
          "team_handball",
          "tennis",
          "toboggan",
          "volleyball",
          "water_ski",
          "yoga"
        ),
        matchAny(
          "tourism",
          "alpine_hut",
          "aquarium",
          "artwork",
          "attraction",
          "bed_and_breakfast",
          "camp_site",
          "caravan_site",
          "chalet",
          "gallery",
          "guest_house",
          "hostel",
          "hotel",
          "information",
          "motel",
          "museum",
          "picnic_site",
          "theme_park",
          "viewpoint",
          "zoo"
        ),
        matchAny(
          "waterway",
          "dock"
        )
      ),
      matchType("polygon")
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmPoiPolygon}.
     */
    public interface Handler {

      void process(OsmPoiPolygon element, FeatureCollector features);
    }
  }

  /** An OSM element that would appear in the {@code osm_aerodrome_label_point} table generated by imposm3. */
  public record OsmAerodromeLabelPoint(
    @Override String name,
    @Override String nameEn,
    @Override String nameDe,
    @Override String aerodromeType,
    @Override String aerodrome,
    @Override String military,
    @Override String iata,
    @Override String icao,
    @Override String ele,
    @Override SourceFeature source
  ) implements
    Row,
    WithName,
    WithNameEn,
    WithNameDe,
    WithAerodromeType,
    WithAerodrome,
    WithMilitary,
    WithIata,
    WithIcao,
    WithEle,
    WithSource {

    public OsmAerodromeLabelPoint(SourceFeature source, String mappingKey) {
      this(
        source.getString("name"),
        source.getString("name:en"),
        source.getString("name:de"),
        source.getString("aerodrome:type"),
        source.getString("aerodrome"),
        source.getString("military"),
        source.getString("iata"),
        source.getString("icao"),
        source.getString("ele"),
        source
      );
    }

    /** Imposm3 "mapping" to filter OSM elements that should appear in this "table". */
    public static final Expression MAPPING = or(
      and(
        matchAny(
          "aeroway",
          "aerodrome"
        ),
        matchType("point")
      ),
      and(
        matchAny(
          "aeroway",
          "aerodrome"
        ),
        matchType("polygon")
      )
    );

    /**
     * Interface for layer implementations to extend to subscribe to OSM elements filtered and parsed as {@link
     * OsmAerodromeLabelPoint}.
     */
    public interface Handler {

      void process(OsmAerodromeLabelPoint element, FeatureCollector features);
    }
  }

  /** Rows with a String access attribute. */
  public interface WithAccess {

    String access();
  }

  /** Rows with a long adminLevel attribute. */
  public interface WithAdminLevel {

    long adminLevel();
  }

  /** Rows with a String aerialway attribute. */
  public interface WithAerialway {

    String aerialway();
  }

  /** Rows with a String aerodrome attribute. */
  public interface WithAerodrome {

    String aerodrome();
  }

  /** Rows with a String aerodromeType attribute. */
  public interface WithAerodromeType {

    String aerodromeType();
  }

  /** Rows with a String aeroway attribute. */
  public interface WithAeroway {

    String aeroway();
  }

  /** Rows with a String amenity attribute. */
  public interface WithAmenity {

    String amenity();
  }

  /** Rows with a String bicycle attribute. */
  public interface WithBicycle {

    String bicycle();
  }

  /** Rows with a String boundary attribute. */
  public interface WithBoundary {

    String boundary();
  }

  /** Rows with a String building attribute. */
  public interface WithBuilding {

    String building();
  }

  /** Rows with a String buildingheight attribute. */
  public interface WithBuildingheight {

    String buildingheight();
  }

  /** Rows with a String buildinglevels attribute. */
  public interface WithBuildinglevels {

    String buildinglevels();
  }

  /** Rows with a String buildingminHeight attribute. */
  public interface WithBuildingminHeight {

    String buildingminHeight();
  }

  /** Rows with a String buildingminLevel attribute. */
  public interface WithBuildingminLevel {

    String buildingminLevel();
  }

  /** Rows with a String buildingpart attribute. */
  public interface WithBuildingpart {

    String buildingpart();
  }

  /** Rows with a String capital attribute. */
  public interface WithCapital {

    String capital();
  }

  /** Rows with a String claimedBy attribute. */
  public interface WithClaimedBy {

    String claimedBy();
  }

  /** Rows with a String colour attribute. */
  public interface WithColour {

    String colour();
  }

  /** Rows with a String construction attribute. */
  public interface WithConstruction {

    String construction();
  }

  /** Rows with a String countryCodeIso31661Alpha2 attribute. */
  public interface WithCountryCodeIso31661Alpha2 {

    String countryCodeIso31661Alpha2();
  }

  /** Rows with a String ele attribute. */
  public interface WithEle {

    String ele();
  }

  /** Rows with a boolean expressway attribute. */
  public interface WithExpressway {

    boolean expressway();
  }

  /** Rows with a String foot attribute. */
  public interface WithFoot {

    String foot();
  }

  /** Rows with a String funicular attribute. */
  public interface WithFunicular {

    String funicular();
  }

  /** Rows with a String height attribute. */
  public interface WithHeight {

    String height();
  }

  /** Rows with a String highway attribute. */
  public interface WithHighway {

    String highway();
  }

  /** Rows with a String horse attribute. */
  public interface WithHorse {

    String horse();
  }

  /** Rows with a String housenumber attribute. */
  public interface WithHousenumber {

    String housenumber();
  }

  /** Rows with a String iata attribute. */
  public interface WithIata {

    String iata();
  }

  /** Rows with a String icao attribute. */
  public interface WithIcao {

    String icao();
  }

  /** Rows with a boolean indoor attribute. */
  public interface WithIndoor {

    boolean indoor();
  }

  /** Rows with a String information attribute. */
  public interface WithInformation {

    String information();
  }

  /** Rows with a boolean isArea attribute. */
  public interface WithIsArea {

    boolean isArea();
  }

  /** Rows with a boolean isBridge attribute. */
  public interface WithIsBridge {

    boolean isBridge();
  }

  /** Rows with a boolean isFord attribute. */
  public interface WithIsFord {

    boolean isFord();
  }

  /** Rows with a String isInCountry attribute. */
  public interface WithIsInCountry {

    String isInCountry();
  }

  /** Rows with a String isInCountryCode attribute. */
  public interface WithIsInCountryCode {

    String isInCountryCode();
  }

  /** Rows with a boolean isIntermittent attribute. */
  public interface WithIsIntermittent {

    boolean isIntermittent();
  }

  /** Rows with a int isOneway attribute. */
  public interface WithIsOneway {

    int isOneway();
  }

  /** Rows with a boolean isRamp attribute. */
  public interface WithIsRamp {

    boolean isRamp();
  }

  /** Rows with a boolean isTunnel attribute. */
  public interface WithIsTunnel {

    boolean isTunnel();
  }

  /** Rows with a String iso31661 attribute. */
  public interface WithIso31661 {

    String iso31661();
  }

  /** Rows with a String iso31661Alpha2 attribute. */
  public interface WithIso31661Alpha2 {

    String iso31661Alpha2();
  }

  /** Rows with a String landuse attribute. */
  public interface WithLanduse {

    String landuse();
  }

  /** Rows with a long layer attribute. */
  public interface WithLayer {

    long layer();
  }

  /** Rows with a String leisure attribute. */
  public interface WithLeisure {

    String leisure();
  }

  /** Rows with a long level attribute. */
  public interface WithLevel {

    long level();
  }

  /** Rows with a String levels attribute. */
  public interface WithLevels {

    String levels();
  }

  /** Rows with a String manMade attribute. */
  public interface WithManMade {

    String manMade();
  }

  /** Rows with a String mappingKey attribute. */
  public interface WithMappingKey {

    String mappingKey();
  }

  /** Rows with a String material attribute. */
  public interface WithMaterial {

    String material();
  }

  /** Rows with a String military attribute. */
  public interface WithMilitary {

    String military();
  }

  /** Rows with a String minHeight attribute. */
  public interface WithMinHeight {

    String minHeight();
  }

  /** Rows with a String minLevel attribute. */
  public interface WithMinLevel {

    String minLevel();
  }

  /** Rows with a String mtbScale attribute. */
  public interface WithMtbScale {

    String mtbScale();
  }

  /** Rows with a String name attribute. */
  public interface WithName {

    String name();
  }

  /** Rows with a String nameDe attribute. */
  public interface WithNameDe {

    String nameDe();
  }

  /** Rows with a String nameEn attribute. */
  public interface WithNameEn {

    String nameEn();
  }

  /** Rows with a String natural attribute. */
  public interface WithNatural {

    String natural();
  }

  /** Rows with a String network attribute. */
  public interface WithNetwork {

    String network();
  }

  /** Rows with a String osmcSymbol attribute. */
  public interface WithOsmcSymbol {

    String osmcSymbol();
  }

  /** Rows with a String place attribute. */
  public interface WithPlace {

    String place();
  }

  /** Rows with a long population attribute. */
  public interface WithPopulation {

    long population();
  }

  /** Rows with a String protectionTitle attribute. */
  public interface WithProtectionTitle {

    String protectionTitle();
  }

  /** Rows with a String publicTransport attribute. */
  public interface WithPublicTransport {

    String publicTransport();
  }

  /** Rows with a String railway attribute. */
  public interface WithRailway {

    String railway();
  }

  /** Rows with a long rank attribute. */
  public interface WithRank {

    long rank();
  }

  /** Rows with a String ref attribute. */
  public interface WithRef {

    String ref();
  }

  /** Rows with a String relbuildingheight attribute. */
  public interface WithRelbuildingheight {

    String relbuildingheight();
  }

  /** Rows with a String relbuildinglevels attribute. */
  public interface WithRelbuildinglevels {

    String relbuildinglevels();
  }

  /** Rows with a String relbuildingminHeight attribute. */
  public interface WithRelbuildingminHeight {

    String relbuildingminHeight();
  }

  /** Rows with a String relbuildingminLevel attribute. */
  public interface WithRelbuildingminLevel {

    String relbuildingminLevel();
  }

  /** Rows with a String relheight attribute. */
  public interface WithRelheight {

    String relheight();
  }

  /** Rows with a String religion attribute. */
  public interface WithReligion {

    String religion();
  }

  /** Rows with a String rellevels attribute. */
  public interface WithRellevels {

    String rellevels();
  }

  /** Rows with a String relminHeight attribute. */
  public interface WithRelminHeight {

    String relminHeight();
  }

  /** Rows with a String relminLevel attribute. */
  public interface WithRelminLevel {

    String relminLevel();
  }

  /** Rows with a String sacScale attribute. */
  public interface WithSacScale {

    String sacScale();
  }

  /** Rows with a String service attribute. */
  public interface WithService {

    String service();
  }

  /** Rows with a String shipway attribute. */
  public interface WithShipway {

    String shipway();
  }

  /** Rows with a String shortName attribute. */
  public interface WithShortName {

    String shortName();
  }

  /** Rows with a SourceFeature source attribute. */
  public interface WithSource {

    SourceFeature source();
  }

  /** Rows with a String sport attribute. */
  public interface WithSport {

    String sport();
  }

  /** Rows with a String station attribute. */
  public interface WithStation {

    String station();
  }

  /** Rows with a String subclass attribute. */
  public interface WithSubclass {

    String subclass();
  }

  /** Rows with a String surface attribute. */
  public interface WithSurface {

    String surface();
  }

  /** Rows with a boolean toll attribute. */
  public interface WithToll {

    boolean toll();
  }

  /** Rows with a String tourism attribute. */
  public interface WithTourism {

    String tourism();
  }

  /** Rows with a String uicRef attribute. */
  public interface WithUicRef {

    String uicRef();
  }

  /** Rows with a String usage attribute. */
  public interface WithUsage {

    String usage();
  }

  /** Rows with a String water attribute. */
  public interface WithWater {

    String water();
  }

  /** Rows with a String waterway attribute. */
  public interface WithWaterway {

    String waterway();
  }

  /** Rows with a String wikipedia attribute. */
  public interface WithWikipedia {

    String wikipedia();
  }

  /** Rows with a int zOrder attribute. */
  public interface WithZOrder {

    int zOrder();
  }

  /** Index to efficiently choose which imposm3 "tables" an element should appear in based on its attributes. */
  public static final MultiExpression<RowClassAndConstructor> MAPPINGS = MultiExpression.of(List.of(
    MultiExpression.entry(new RowClassAndConstructor(OsmWaterPolygon.class, OsmWaterPolygon::new),
      OsmWaterPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmWaterwayLinestring.class, OsmWaterwayLinestring::new),
      OsmWaterwayLinestring.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmLandcoverPolygon.class, OsmLandcoverPolygon::new),
      OsmLandcoverPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmLandusePolygon.class, OsmLandusePolygon::new),
      OsmLandusePolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmPeakPoint.class, OsmPeakPoint::new), OsmPeakPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmMountainLinestring.class, OsmMountainLinestring::new),
      OsmMountainLinestring.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmParkPolygon.class, OsmParkPolygon::new),
      OsmParkPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmAerowayPolygon.class, OsmAerowayPolygon::new),
      OsmAerowayPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmAerowayLinestring.class, OsmAerowayLinestring::new),
      OsmAerowayLinestring.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmAerowayPoint.class, OsmAerowayPoint::new),
      OsmAerowayPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmHighwayLinestring.class, OsmHighwayLinestring::new),
      OsmHighwayLinestring.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmRailwayLinestring.class, OsmRailwayLinestring::new),
      OsmRailwayLinestring.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmAerialwayLinestring.class, OsmAerialwayLinestring::new),
      OsmAerialwayLinestring.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmShipwayLinestring.class, OsmShipwayLinestring::new),
      OsmShipwayLinestring.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmHighwayPolygon.class, OsmHighwayPolygon::new),
      OsmHighwayPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmHighwayPoint.class, OsmHighwayPoint::new),
      OsmHighwayPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmBuildingPolygon.class, OsmBuildingPolygon::new),
      OsmBuildingPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmMarinePoint.class, OsmMarinePoint::new),
      OsmMarinePoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmContinentPoint.class, OsmContinentPoint::new),
      OsmContinentPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmCountryPoint.class, OsmCountryPoint::new),
      OsmCountryPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmIslandPolygon.class, OsmIslandPolygon::new),
      OsmIslandPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmIslandPoint.class, OsmIslandPoint::new),
      OsmIslandPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmStatePoint.class, OsmStatePoint::new), OsmStatePoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmCityPoint.class, OsmCityPoint::new), OsmCityPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmHousenumberPoint.class, OsmHousenumberPoint::new),
      OsmHousenumberPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmPoiPoint.class, OsmPoiPoint::new), OsmPoiPoint.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmPoiPolygon.class, OsmPoiPolygon::new), OsmPoiPolygon.MAPPING),
    MultiExpression.entry(new RowClassAndConstructor(OsmAerodromeLabelPoint.class, OsmAerodromeLabelPoint::new),
      OsmAerodromeLabelPoint.MAPPING)
  ));

  /**
   * Returns a map from imposm3 "table row" class to the layers that have a handler for it from a list of layer
   * implementations.
   */
  public static Map<Class<? extends Row>, List<RowHandlerAndClass<?>>> generateDispatchMap(List<?> handlers) {
    Map<Class<? extends Row>, List<RowHandlerAndClass<?>>> result = new HashMap<>();
    for (var handler : handlers) {
      if (handler instanceof OsmWaterPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmWaterPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmWaterwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmWaterwayLinestring.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmLandcoverPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmLandcoverPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmLandusePolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmLandusePolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmPeakPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmPeakPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmMountainLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmMountainLinestring.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmParkPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmParkPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmAerowayPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmAerowayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayLinestring.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmAerowayPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmHighwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmHighwayLinestring.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmRailwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmRailwayLinestring.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmAerialwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmAerialwayLinestring.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmShipwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmShipwayLinestring.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmHighwayPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmHighwayPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmHighwayPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmHighwayPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmBuildingPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmBuildingPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmMarinePoint.Handler typedHandler) {
        result.computeIfAbsent(OsmMarinePoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmContinentPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmContinentPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmCountryPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmCountryPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmIslandPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmIslandPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmIslandPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmIslandPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmStatePoint.Handler typedHandler) {
        result.computeIfAbsent(OsmStatePoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmCityPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmCityPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmHousenumberPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmHousenumberPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmPoiPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmPoiPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmPoiPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmPoiPolygon.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
      if (handler instanceof OsmAerodromeLabelPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmAerodromeLabelPoint.class, cls -> new ArrayList<>())
          .add(new RowHandlerAndClass<>(typedHandler.getClass(), typedHandler::process));
      }
    }
    return result;
  }
}
